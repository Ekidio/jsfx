// Track Compressor
//
// Flexible compressor with very low CPU footprint.
//
// The idea was to make everything I care about in a compressor available in one plugin.
//
// It can switch between internal and external key signals (sidechain) that go into the detector.
// There are stereo setups as well as mono modes, two of them are designed to receive the actual
// signal on one channel and the sidechain signal on the opposite channel.
//
// The detector mode can be faded between (modern) feed-forward and (classic) feed-back. FF at 0%
// will calculate a gain reduction factor for each sample independently. FB at 100% lets previous
// GR from the former sample/s flow into new samples' GR. This makes the overall behaviour of the
// compressor more stable and predictable, but also slower to respond to fast/large changes.
//
// There'e an RMS averager that will calculate the average sample value over a settable window of
// time, setting it to 0 ms window will make the compressor respond to each peak sample directly.
// Similar to feedback topology, an increased RMS window will make the behaviour more predictable
// and stable, but a smaller/no RMS window catches faster transients and attenuates more quickly.
//
// The "knee" refers to the point at which the compressor kicks in and starts compressing. "Hard
// knee" means zero compression happens up to a certain point, and as soon as that point is hit,
// the compression immediately kicks in at full amount. "Soft knee" means the ratio of compression
// will start already below the set threshold at a softer amount, and increases gradually above
// the cutoff point to reach its full ratio. This makes the transfer curve of the compression look
// like a round curve rather than a hard fold, hence "soft".
// 
// A hard knee can be considered modern, digital, maybe a bit brutish, since it does nothing until
// required, and then suddenly kicks in at full ratio. A soft knee can be considered maybe more
// analog and vintage, due to the variable ratio and the slightly (perceived) imprecise triggering
// that already starts below the set threshold mark.
//
// The Range parameter controls the maximum amount of gain reduction to apply. If this is set to
// -40 dB, the full range of, theoretically, up to -400 dB of Gain Reduction is applied if need be.
// If the value is set lower, then only the specified gain reduction amount between 0 and -39.x dB
// will be applied.
//
// Stereo linking uses the averaged value of both sidechain (internal or external) channels for 
// reference. At 0% there is no stereo linking, which means the compressor operates in dual mono
// mode, this is good to get two independent signals levelled. At 100%, there is total linking,
// which means that both channels will be compressed equally, this is good for things like grouped
// drums with several kit elements spanning the entire stereo field.
//
// There's a sidechain HP filter that will cut the lows off the detector signal, this is useful
// to make the compressor respond less to bass-heavy signal parts like kick drums or distorted
// guitar palm mutes and helps reduce pumping.
//
// Automatic Makeup Gain compensation will factor in an amount of post-compression gain increase.
// The intention of this is to bring the volume of a signal that was attenuated with compression
// back up to somewhere around where it used to be. This is done with a static formula, so there
// can be settings where it results in an output either a lot louder or a lot quieter than the
// input signal was, so be careful.
//
// The saturation is not fully dynamic but depends on the amount of automatic makeup gain that
// would be applied, even if auto-makeup isn't enabled. So the more the signal is attenuated by
// compression, the more intense the saturation will become. The saturated sample is mixed with
// the dry sample at the percentage set with the GUI Saturation parameter. So it's possible to
// mix subtle saturation at subtle compression in but at a high amount, or to mix heavy saturation
// at more heavy compression in at a lower amount.
//
// Finally, the Dry/Wet mix defines the percentages at which the unprocessed and processed signals
// are blended together. The blending happens 100/0 - 50/50 - 0/100, so at the extreme values the
// signal will either be 100% dry (0%) or 100% wet (100%), and in between there will be a balance
// of both the dry input and the wet processed signal.
//
// author: chokehold
// url:    https://github.com/chkhld/jsfx/
// tags:   processing compressor dynamics gain
//
desc: Track Comp

in_pin:Input L
in_pin:Input R
in_pin:External SC / L
in_pin:External SC / R
out_pin:Output L
out_pin:Output R

slider1: dBGain=0<-12, 12, 0.01> Input Gain [dB]
slider2: compFeedbk=25<0, 100, 0.01> Feedback [%]
slider3: compThresh=0<-60, 0, 0.01> Threshold [dB]
slider4: compRatio=4<0.1, 20, 0.1> Ratio [x:1]
slider5: compAttack=10<0.001, 100, 0.01> Attack [ms]
slider6: compRelease=200<20, 1500, 0.01> Release [ms]
slider7: compWindow=0<0,150,0.01> RMS Window [ms]
slider8: compKnee=4.5<0,12,0.01> Hard/Soft Knee [dB]
slider9: compRange=-40<-40, 0, 0.01> Comp. Range [dB]
slider10:linkAmount=50<0, 100, 1> Stereo Link [%]
slider11:scFreq=70<20, 350, 1> SC High Pass [Hz]
slider12:autoGain=0<0,1,{Enabled,Disabled}> Auto Makeup Gain
slider13:saturation=25<0,100,0.01> Saturation [%]
slider14:dBTrim=0<-12, 12, 0.01> Output Gain [dB]
slider15:pctMix=100<0,100,0.01> Dry/Wet Mix [%]
slider16:routing=0<0, 3,{Stereo (internal SC),Stereo (external SC 3-4),Mono (L),Mono (R),Mono (signal L / key R),Mono (key L / signal R)}> Routing

@init
  
  // Various convenience constants
  M_LN10_20 = 8.68588963806503655302257837833210164588794011607333;
  floatFloor = 0.0000000630957; // dBToGain --> ~ -144 dBfs
  halfPi = $PI * 0.5;
  
  // Helper functions
  function dBToGain       (decibels) (10.0 ^ (decibels / 20.0));
  function fastReciprocal (value)    (sqr(invsqrt(value)));
  function gainTodB (float) local (below)
  (
    float = abs(float);
    below = float < floatFloor;
    float = below * floatFloor + (!below) * float;
    (log(float) * M_LN10_20);
  );
  
  // Hyperbolic tangent approximation
  function tanh (number) local (expPos, expNeg)
  (
    expPos = exp(number);
    expNeg = fastReciprocal(expPos); // 1 / exp(-number)
    (expPos - expNeg) / (expPos + expNeg);
  );
  
  // SIDECHAIN FILTER
  //
  // Implemented after Andrew Simper's State Variable Filter paper.
  // https://cytomic.com/files/dsp/SvfLinearTrapOptimised2.pdf
  //
  function eqHP (Hz, Q) instance (a1, a2, a3, m0, m1, m2) local (g, k)
  (
    g = tan(halfPi * (Hz / srate)); k = fastReciprocal(Q);
    a1 = fastReciprocal(1.0 + g * (g + k)); a2 = a1 * g; a3 = a2 * g;
    m0 = 1.0; m1 = -k; m2 = -1.0;
  );
  //
  function eqTick (sample) instance (v1, v2, v3, ic1eq, ic2eq)
  (
    v3 = sample - ic2eq; v1 = this.a1 * ic1eq + this.a2 * v3;
    v2 = ic2eq + this.a2 * ic1eq + this.a3 * v3;
    ic1eq = 2.0 * v1 - ic1eq; ic2eq = 2.0 * v2 - ic2eq;
    (this.m0 * sample + this.m1 * v1 + this.m2 * v2);
  );
  
  // SATURATION PROCESS
  //
  function saturate (drive)
  (
    this  = dryMix * this + satMix * tanh(this * drive * sqr(satMix));
  );
  
  // PRIMITIVE ENVELOPE FOLLOWER
  //
  // Follows the envelope of a signal at the speed set with the
  // msTime argument. Higher ms values mean slower response to
  // the signal, lower ms values mean faster response.
  //
  function envSetup (msTime) instance (coeff) local ()
  (
    coeff = exp(-1000 * fastReciprocal(msTime * srate));
  );
  //
  // It's possible to do the calculations in dB or in gain factors.
  // Because this compressor uses so many different dB values, like
  // Range and Knee, I decided to not constantly convert the values
  // back and forth, but to just run the envelopes on dB values.
  //
  // The sample should already be abs()-ed by here to positive dB.
  //
  // The envelope is NOT kept in this variable, but in the PARENT
  // variable containing this one. This is the case so one variable
  // can hold one envelope value as well as two follower instances
  // with different timings that can both work on the same state.
  //
  function envTick (dBsample) instance (coeff) local (active)
  (
    active = (coeff != 0);
    (!active * dBsample) + (active * (dBsample + coeff * (this..envelope - dBsample)));
  );
  
  // ATTACK / RELEASE ENVELOPE
  //
  // This will turn a variable into a full envelope container that
  // holds an envelope state as well as two followers that will be
  // used for the attack and release stages separately.
  //
  function attRelSetup (msAttack, msRelease) instance (envAtt, envRel) local ()
  (
    // Set up the two envelope followers.
    // One for attack, one for release.
    envAtt.envSetup(msAttack);
    envRel.envSetup(msRelease);
  );
  //
  // This calculates the new envelope state for the current sample.
  // If the current sample is above the current envelope state, let
  // the attack envelope trigger. If the current sample is smaller
  // than the current envelope state, let the release envelope run.
  // 
  // The sample should already be abs()-ed by here to positive dB.
  //
  function attRelTick (dBsample) instance (envelope, envAtt, envRel) local (above)
  (
    above = (dBsample > envelope);
    
    // If above, get attack + if not above, get release
    envelope = (above * envAtt.envTick(dBsample)) + (!above * envRel.envTick(dBsample));
  );
  
  // RMS AVERAGER
  //
  // "Wraps" yet another envelope follower to create the RMS 
  // averager. This is like a brake for incoming samples, so
  // instead of shooting every incoming sample directly into
  // the attack/release envelope detector, this will average
  // the incoming values over a certain period of time, a so
  // called "window". The length of the window is set in ms
  // and defines over how long a time the incoming samples
  // are smoothed.
  //
  function rmsSetup (msWindow) instance (rmsEnv, average) local ()
  (
    rmsEnv.envSetup(msWindow);
  );
  //
  function rmsTick (sample) instance (rmsEnv, average, envelope) local ()
  (
    envelope = rmsEnv.envTick(sample * sample);
    sqrt(envelope);
  );
  
  // GAIN CALCULATOR
  //
  // From all the various levels, this will calculate more
  // values required to calculate with later on. Included
  // are hard/soft knee limits and the makeup gain.
  //
  // Automatically compensating the signal can be switched
  // off, but makeup gain is still calculated because it's
  // used as a factor in the saturation stage.
  //
  // The formula to calculate the gain compensation value was
  // implemented after Tom Duffy at Tascam and Charles Hoffman
  // at Black Ghost Audio.
  // https://music.columbia.edu/pipermail/music-dsp/2009-September/068027.html
  // https://www.blackghostaudio.com/blog/the-ultimate-guide-to-compression
  //
  function gainCalcSetup (dBThreshold, fullRatio, dBKnee, dBRange) instance (threshold, ratio, makeup, knee, kneeWidth, kneeUpper, kneeLower, range) local ()
  (
    threshold = dBThreshold;            // signed dBfs
    ratio = fastReciprocal(fullRatio);  // 1/x --> compression < 1, expansion > 1
    makeup = dBToGain(abs((threshold + (abs(threshold) * ratio)) * 0.4)); // 0.5 went too loud too quickly
    knee = dBKnee;
    kneeWidth = knee * 0.5;
    kneeUpper = threshold + kneeWidth;
    kneeLower = threshold - kneeWidth;
    range = dBRange;
  );
  //
  function gainCalcTick (dBsample) instance (ratio, knee, kneeLower, kneeUpper, threshold, range) local (dBReduction, slope)
  (
    dBReduction = dBsample;
    slope = 1.0 - ratio;
    
    (knee > 0.0) && (dBsample > kneeLower) && (dBsample < kneeUpper) ?
    (
      slope *= ((dBsample - kneeLower) / knee) * 0.5;
      dBReduction = slope * (kneeLower - dBsample);
    ):(
      dBReduction = min(0.0, slope * (threshold - dBsample));
    );
    
    dBToGain(max(dBReduction, range));
  );
  
  // COMPRESSOR
  //
  // Finally, now all the individual components created
  // earlier are combined into a single big compressor.
  //
  // Full ratio: >1 for compression, <1 for expansion
  // dBThreshold, dBRange: signed dBfs
  // dBKnee: absolute/positive dB
  // pctFeedback: % of previous GR detector feedback
  //
  function compSetup (msAttack, msRelease, msWindow, dBThreshold, fullRatio, dBKnee, dBRange, pctFeedback, autoMakeup) instance (attRel, rms, calc, feedback, autogain) local ()
  (
    attRel.attRelSetup(msAttack, msRelease);
    rms.rmsSetup(msWindow);
    calc.gainCalcSetup(dbThreshold, fullRatio, dBKnee, dBRange);
    feedback = pctFeedback * 0.01;
    autogain = autoMakeup;
  );
  //
  function compTick (sample) instance (GR, feedback, rms, attRel, calc, autogain) local (feedbackFactor, keyGain, keyDecibels, gainAdjust)
  (
    // The amount of previous GR to apply to this sample,
    // this is essentially a 1-sample-delayed feedback.
    feedbackFactor = 1.0 - ((1.0 - GR) * feedback);
    
    // The sidechain key sample value as a float gain factor
    keyGain = abs(sample) * feedbackFactor;
    
    // If an RMS window is set up, run the key 
    // sample through the RMS averager envelope.
    rms.rmsEnv.coeff > 0 ? keyGain = rms.rmsTick(keyGain);
    
    // Turn the key sample into a dBfs value
    keyDecibels = gainTodB(keyGain);
    
    // Send the dBfs sample value into the attack/release
    // envelope follower and get a new envelope state.
    attRel.attRelTick(keyDecibels);
    
    // Calculate the required gain reduction for this input
    // sample based on user-specified parameters. This will
    // output the GR value as a float gain factor, NOT in dB.
    GR = calc.gainCalcTick(attRel.envelope);
    
    // Factor in automatic gain compensation if set
    gainAdjust = (autogain == 0) ? calc.makeup : 1.0;
    
    // This return value is the float factor gain adjustment
    // that needs to be applied to the signal sample, it is
    // NOT an actual sample value.
    GR * gainAdjust;
  );
  
@slider
  
  // The maximum amount of gain reduction to apply.
  maxRange = (compRange == -40) ? -400 : compRange;
  
  // Prepares two compressor variables, one for each channel.
  compL.compSetup(compAttack, compRelease, compWindow, compThresh, compRatio, compKnee, maxRange, compFeedbk, autoGain);
  compR.compSetup(compAttack, compRelease, compWindow, compThresh, compRatio, compKnee, maxRange, compFeedbk, autoGain);

  // Calculates amount of stereo-linking in the key signal
  lnkMix = linkAmount * 0.01;
  splMix = 1.0 - lnkMix;
  
  // Make the sidechain high-pass filters
  filterL.eqHP(scFreq, 1.5);
  filterR.eqHP(scFreq, 1.5);
  
  // Turn input/output dB gain values into float factors
  gainIn  = dBToGain(dBGain);
  gainOut = dBToGain(dBTrim);
  
  // The amounts of saturated and un-saturated signal to mix
  satMix = saturation * 0.01;
  dryMix = 1.0 - satMix;
  
  // The amounts of dry and processed signal to blend
  wetDry = pctMix * 0.01;
  dryWet = 1.0 - wetDry;
  
@block
  
  
  
@sample
  
  // Storing dry samples here for later dry/wet mixing
  dryL = spl0;
  dryR = spl1;
  
  // Dummy-assigning these here so that they exist
  // outside the scopy of the if-blocks below.
  keyL = keyR = 0.0;
  
  // Input gain. Branching is slow, so it's faster to
  // just do this multicplication instead of running
  // a check to see if it's needed, i.e. dBGain != 0
  spl0 *= gainIn;
  spl1 *= gainIn;
  
  // CHANNEL ROUTING MODES
  //
  // Stereo channels with internal sidechain
  routing == 0 ?
  (
    // Filter sidechain samples and make them positive
    keyL = abs(filterL.eqTick(spl0));
    keyR = abs(filterR.eqTick(spl1));
    
    // Stereo-link the detector signal?
    (lnkMix > 0) ?
    (
      // If stereo-linked, take average of both channels
      linked = sqrt(sqr(keyL) + sqr(keyR)) * lnkMix;
      
      keyL *= splMix;
      keyR *= splMix;
      
      keyL += linked;
      keyR += linked;
    );
    
    // Run the comp calculations on whatever mixture
    // of the two input channels is left in the keys,
    // then apply the resulting GR to the signal.
    spl0 *= compL.compTick(keyL);
    spl1 *= compR.compTick(keyR);
  );
  
  // Stereo ext SC
  (routing == 1) ? 
  (
    // Filter sidechain samples and make them positive
    keyL = abs(filterL.eqTick(spl2));
    keyR = abs(filterR.eqTick(spl3));
    
    // Stereo-link the detector signal?
    lnkMix > 0 ?
    (
      // If stereo-linked, take average of both channels
      linked = sqrt(sqr(keyL) + sqr(keyR)) * lnkMix;
      
      keyL *= splMix;
      keyR *= splMix;
      
      keyL += linked;
      keyR += linked;
    );
    
    // Run the comp calculations on whatever mixture
    // of the two input channels is left in the keys,
    // then apply the resulting GR to the signal.
    spl0 *= compL.compTick(keyL);
    spl1 *= compR.compTick(keyR);
  );
  
  // Mono L
  routing == 2 ?
  (
    // Process L channel and pass its result through
    // to R channel
    spl1 = spl0 *= compL.compTick(abs(filterL.eqTick(spl0)));
  );
  
  // Mono R
  routing == 3 ? 
  (
    // Process R channel and pass its result through
    // to L channel 
    spl0 = spl1 *= compR.compTick(abs(filterR.eqTick(spl1)));
  );
  
  // Mono L <- R
  routing == 4 ?
  (
    // Process L input channel using R input as key.
    // Duplicate result into output channel R.
    spl1 = spl0 *= compL.compTick(abs(filterL.eqTick(spl1)));
  );
  
  // Mono L -> R
  routing == 5 ? 
  (
    // Process R input channel using L input as key.
    // Duplicate result into output channel L.
    spl0 = spl1 *= compR.compTick(abs(filterR.eqTick(spl0)));
  );  
  
  // Saturation stage
  saturation > 0 ?
  (
    spl0.saturate(compL.calc.makeup * 0.35);
    spl1.saturate(compR.calc.makeup * 0.35); 
  );
  
  // Output gain. Probably faster to just multiply
  // rather than using conditional branching. The
  // automatic gain compensation has already been
  // handled and factored in earlier by compTick().
  spl0 *= gainOut;
  spl1 *= gainOut;
  
  // Dry/wet mix
  // 
  // Mixes unprocessed and processed signals this way:
  // - 0.0: 100% dry
  // - 0.5:  50% dry + 50% wet
  // - 1.0: 100% wet
  //
  wetDry < 1 ?
  (
    spl0 = dryWet * dryL + wetDry * spl0;
    spl1 = dryWet * dryR + wetDry * spl1;
  );
